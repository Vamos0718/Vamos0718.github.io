<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Stack</title>
      <link href="/posts/8069546e.html"/>
      <url>/posts/8069546e.html</url>
      
        <content type="html"><![CDATA[<h1 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h1><p><strong>Stack</strong> is one form of data structure, it possesses the Last-In-First-Out character. This data structure only could be manipulated in the one endpoint which is named <strong>stack top</strong>. Stack top is dynamic, when push or pop data occur, the another endpoint which is named <strong>stack bottom</strong> is still. In addition to push and pop, there are much operations we can operate, for instance, getting size, determining empty.</p><p>By stack, program could implement some function, e.g., facility equivalent of recursion. There is a example of stack.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data[<span class="number">10</span>]; <span class="comment">//define the max capacity of stack</span></span><br><span class="line">    <span class="type">int</span> TopIndex; <span class="comment">//this TopIndex refers to the current index of the top element</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Stack</span>():<span class="built_in">TopIndex</span>(<span class="number">-1</span>)&#123;&#125; <span class="comment">//initialization value is -1, means that there is no push </span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(TopIndex==<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(TopIndex==<span class="number">9</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isFull</span>())&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;error push&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        data[++TopIndex]=value;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;error pop&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//notice the necessary return value</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data[TopIndex--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;error top&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//notice the necessary return value</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data[TopIndex];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;error print&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=TopIndex;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            cout&lt;&lt;data[i]&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Stack myStack;</span><br><span class="line">    myStack.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">    myStack.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">    myStack.<span class="built_in">pop</span>();</span><br><span class="line">    myStack.<span class="built_in">printStack</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 2. Study Note </category>
          
          <category> 2.2. Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linked List</title>
      <link href="/posts/cd937a95.html"/>
      <url>/posts/cd937a95.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linked-List"><a href="#Linked-List" class="headerlink" title="Linked List"></a>Linked List</h1><p>The <strong>linked list</strong> belongs to <strong>linear list</strong>, apart from linked list, linear list also has a branch called <strong>sequential list</strong> whose memory is consistent, one classic example is array. Relatively, linked list possesses discontinuous memory, each element is allocated memory respectively, each memory region is connected by pointer.</p><p>By the difference of usage and function, linked list could be divided into for branches which are called <strong>singly linked list</strong>, <strong>singly circular list</strong>, <strong>doubly linked list</strong>, <strong>doubly circular list</strong>. </p><p>The four forms are defined and initialized like this.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//singly linked list</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> val): <span class="built_in">data</span>(val), <span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//singly circular list</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CirListNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    CirListNode* next;</span><br><span class="line">    <span class="built_in">CirListNode</span>(<span class="type">int</span> val): <span class="built_in">data</span>(val), <span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//doubly linked list</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DoubleListNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    DoubleListNode* prev;</span><br><span class="line">    DoubleListNode* next;</span><br><span class="line">    <span class="built_in">DoubleListNode</span>(<span class="type">int</span> val): <span class="built_in">data</span>(val), <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//doubly circular list</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DoubleCirListNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    DoubleCirListNode* prev;</span><br><span class="line">    DoubleCirListNode* next;</span><br><span class="line">    <span class="built_in">DoubleCirListNode</span>(<span class="type">int</span> val): <span class="built_in">data</span>(val), <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> For normal list, the <em>next</em> from the last node refers to null, and the <em>prev</em> (if there is) from the first node also refers to null . It likes one road has the starting point and endpoint. But for circular list, the <em>next</em> from the last node will refer to the first node, and the <em>prev</em> (if there is) from the the first node will refer to the last node. That is, it likes one cycle.</p><p>Ordinarily, the node before the first node is called <strong>headnode</strong> which is created for counting how much node this list has (exclude the headnode), so the <em>data</em> from headnode stores the node number within this list. Thus, while we initialize the list, the <em>data</em>, in more detail, the <em>data</em> from the first node is accustomed to be 0.  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//examlpe of usage,not use headnode</span></span><br><span class="line">DoubleCirListNode* dcList= <span class="keyword">new</span> <span class="built_in">DoubleCirListNode</span>(<span class="number">1</span>)</span><br><span class="line">dcList-&gt;next = <span class="keyword">new</span> <span class="built_in">DoubleCirListNode</span>(<span class="number">2</span>);</span><br><span class="line">dcList-&gt;next-&gt;prev = dcList;</span><br><span class="line">dcList-&gt;next-&gt;next = <span class="keyword">new</span> <span class="built_in">DoubleCirListNode</span>(<span class="number">3</span>);</span><br><span class="line">dcList-&gt;next-&gt;next-&gt;prev = dcList-&gt;next;</span><br><span class="line">dcList-&gt;next-&gt;next-&gt;next = dcList; <span class="comment">// 指向头节点形成循环</span></span><br></pre></td></tr></table></figure><p>We can also define some operations we need on the linked list, such as <strong>headinsert</strong>, <strong>tailinsert</strong>, <strong>delete</strong>, <strong>print</strong> and more.</p>]]></content>
      
      
      <categories>
          
          <category> 2. Study Note </category>
          
          <category> 2.2. Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linklist </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Version of C Library Header</title>
      <link href="/posts/4ee8ee3c.html"/>
      <url>/posts/4ee8ee3c.html</url>
      
        <content type="html"><![CDATA[<h1 id="C-Version-of-C-Library-Header"><a href="#C-Version-of-C-Library-Header" class="headerlink" title="C++ Version of C Library Header"></a>C++ Version of C Library Header</h1><p>In addition to those facilities specifically defined for C++, C++ library incorporates the C library. Those C library named <em>name.h</em> are named differently in C++, which is <em>cname</em>. </p><p>Exclude the difference of the form of name, there is a more core difference which judges why C++ programmers should use the library name of C++, but not of C. That is, the name defined in <em>cname</em> headers are defined inside the <em>std</em> namespace, whereas those defined in the <em>name.h</em> versions are not.</p><p>So, using the <em>name.h</em> headers will put the extra burden on the programmer to remember which library names are inherited from C and whcih are unique to C++.</p>]]></content>
      
      
      <categories>
          
          <category> 2. Study Note </category>
          
          <category> 2.1. C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Header </tag>
            
            <tag> Namespace </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Range-Based for Statement</title>
      <link href="/posts/b59a3782.html"/>
      <url>/posts/b59a3782.html</url>
      
        <content type="html"><![CDATA[<h1 id="Range-Based-for-Statement"><a href="#Range-Based-for-Statement" class="headerlink" title="Range-Based for Statement"></a>Range-Based <em>for</em> Statement</h1><p>To access every element of a sequence, the best way is that using <strong>range for</strong> statement, the syntactic form is as follows.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(declaration: expression)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure><p>Let’s explain the part one by one, <em>expression</em> is an object of a type that represents a sequence, and <em>declaration</em> defines a variable to access every element in the sequence. On each iteration, the variable initialized by the value of the next element in the sequence. The <em>statement</em> makes us could perform some operation on the variable which initialized from the sequence.</p><p>As we know, the <em>string</em> type represents a sequence of character, so we can use a <em>string</em> object as the <em>expression</em> to be printed in a range <em>for</em>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string str=<span class="string">&quot;Henan&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> c: str)</span><br><span class="line">    cout&lt;&lt;c&lt;&lt;endl;<span class="comment">//print the current character followed by a newline</span></span><br></pre></td></tr></table></figure><p>In the <em>declaration</em>, we can define a reference which binds to <em>char</em> type, in this way, we could operate the element of the sequence indirectly. Such as, by the library <em>toupper</em> function which takes a character and returns the uppercase version of that character, we could convert a <em>string</em> to all uppercase letters.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; c: s)</span><br><span class="line">    c=<span class="built_in">toupper</span>(s);</span><br><span class="line">cout&lt;&lt;s&lt;&lt;endl;<span class="comment">//the output of this code is HELLO</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 2. Study Note </category>
          
          <category> 2.1. C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Statement </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Some Notes About string</title>
      <link href="/posts/14c6fac6.html"/>
      <url>/posts/14c6fac6.html</url>
      
        <content type="html"><![CDATA[<h1 id="Some-Notes-About-string"><a href="#Some-Notes-About-string" class="headerlink" title="Some Notes About string"></a>Some Notes About <em>string</em></h1><h2 id="Defining-and-Initializing-strings"><a href="#Defining-and-Initializing-strings" class="headerlink" title="Defining and Initializing strings"></a>Defining and Initializing <em>string</em>s</h2><p>There is one way to initialize <em>string</em>s that i didn’t know before: </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(n,<span class="string">&#x27;c&#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure><p> It means that initialize <em>s1</em> with n copies of character ‘c’, then <em>s1</em> will hold these data “cccccccccc”.</p><h2 id="Operations-on-strings"><a href="#Operations-on-strings" class="headerlink" title="Operations on strings"></a>Operations on <em>string</em>s</h2><p>The library defines much operations <em>string</em>s can perform, the same there is still some forms i’m not familiar,like these.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="built_in">getline</span>(istream,s);<span class="comment">//reads a line of input from istream into s. Return istream, that is, this function could do chain input. </span></span><br><span class="line">s[n];<span class="comment">//returns a reference to the char at position n in s;positions start at 0.</span></span><br><span class="line">s.<span class="built_in">empty</span>();</span><br><span class="line">s.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure><h2 id="Reading-an-Unknown-Number-of-strings"><a href="#Reading-an-Unknown-Number-of-strings" class="headerlink" title="Reading an Unknown Number of strings"></a>Reading an Unknown Number of <em>string</em>s</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;s)&#123;<span class="comment">//returns cin,chained inputs.</span></span><br><span class="line">        cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This program reads until end-of-file (or invalid input) which used by tapping keyword Ctrl+Z together,then program falls out of the <em>while</em>.</p><h2 id="Adding-Literals-and-strings"><a href="#Adding-Literals-and-strings" class="headerlink" title="Adding Literals and strings"></a>Adding Literals and <em>string</em>s</h2><p>By type conversion, we can instead <em>string</em>s type with the given type that could convert its type to <em>string</em>s (e.g., character literals and character string literals). When we use <em>+ operator</em> as follows, there are constraints while we mix <em>string</em>s and string or character literals.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string s=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">string s1=s+ <span class="string">&quot;,&quot;</span>;<span class="comment">//ok</span></span><br><span class="line">string s2=<span class="string">&quot;hello&quot;</span>+ <span class="string">&quot;,&quot;</span>;<span class="comment">//error</span></span><br><span class="line">string s3=s+ <span class="string">&quot;,&quot;</span>+ <span class="string">&quot;world&quot;</span>;<span class="comment">//ok</span></span><br><span class="line">string s4=<span class="string">&quot;hello&quot;</span>+ <span class="string">&quot;,&quot;</span>+ s;<span class="comment">//error</span></span><br></pre></td></tr></table></figure><p>In the above case, we need to promise at least one operand side the <em>+ operator</em> is <em>string</em>s type.  About the initalization of s3, it could group as</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string s3=(s+ <span class="string">&quot;,&quot;</span>)+ <span class="string">&quot;world&quot;</span>;</span><br></pre></td></tr></table></figure><p>The subexpression <em>s+ “,”</em> returns a <em>string</em>s, which forms the left-hand operand of the second + operator. So the initalization of s3 and s1 is legal. For the same reasons, the initalization of s4 and s2 is illegal.</p>]]></content>
      
      
      <categories>
          
          <category> 2. Study Note </category>
          
          <category> 2.1. C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Header Should Not Include using Declaration</title>
      <link href="/posts/c7c7d983.html"/>
      <url>/posts/c7c7d983.html</url>
      
        <content type="html"><![CDATA[<h1 id="Header-Should-Not-Include-using-Declaration"><a href="#Header-Should-Not-Include-using-Declaration" class="headerlink" title="Header Should Not Include using Declaration"></a>Header Should Not Include <em>using</em> Declaration</h1><p>To use namespace members easily,language inducts the <strong>using declaration</strong>.A <em>using</em> declaration has the form:  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>:: name;</span><br></pre></td></tr></table></figure><p>But about headers,if one header includes the <em>using</em> declaration,then every program which include the header all will get the same <em>using</em> declaration,which would make the program that didn’t intend to use the specified library name encounter unexpected name conflicts.</p>]]></content>
      
      
      <categories>
          
          <category> 2. Study Note </category>
          
          <category> 2.1. C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Header </tag>
            
            <tag> Namespace </tag>
            
            <tag> Statement </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/4a17b156.html"/>
      <url>/posts/4a17b156.html</url>
      
        <content type="html"><![CDATA[<h1 id="XingHorizons"><a href="#XingHorizons" class="headerlink" title="XingHorizons"></a>XingHorizons</h1>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
